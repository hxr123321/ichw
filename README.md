# 作业2

### 1.图灵为什么要证明停机问题
* 停机问题，即不存在一个程序能判断是否所有程序在运行一定次数后便停止。因为当我们在程序中输入这条程序本身，然后人为地规定它：若判断该程序停止，则继续进行下一次判断；反之，则停止。那么这个程序就会陷入一种癫狂而纠结的状态，因为它停也不是，不停也不是，这和理发师悖论有异曲同工之妙。  
* 那么图灵为什么要证明停机问题呢？  
在我看来，第一，图灵大概是想说明计算机编程或者程序天生的不完备性。计算机固然为人类社会打开了一个新世界，但是这个世界并不是完美的，它也存在逻辑上的一些悖论和局限。  
第二，当然，他也很好地说明了程序本身也是一种数据，也可以作为数据被输入。

### 2.向中学生解释二进制补码的原理
* 首先，补码的出现是为了解决整数（含负数）的运算问题。原码表示正负数易混淆，而反码表示下有两个零，在运算的时候均会出现bug，补码很好地弥补了这一缺陷。
* 以4位为例，从0000到1111共16个数字，我们把这16个数字分为两半，从0000到0111表示0~7这8个数字，而从1000到1111表示-8到-1这8个数字。这样一来，正好转了一圈。这就使得我们的数字像分布在一个钟表盘上，-1（1111）加上1，本来应该进一位，可由于位数限制，就成为了0（0000），这在逻辑上也是合理的。
* 直观看来，补码便满足以下规律：  
① 第一位是符号位，0为正，1为负。  
② 正数的补码即为原码，而负数的补码相当于原码求反码（符号位不变），再加一。  
③ 对一个数进行两次补码运算，又回到了它本身。  
④ 只有一个零。  
* 这样，计算机在遇到减法运算时，只需要将-n转化为+(-n)，-n用补码表示，运算就能变得合理。

### 3.用16bit的浮点数表示一系列数
① +0：0 0000000 00000000；-0：1 0000000 00000000  
② +1：0 0111111 00000000；-1：1 0111111 00000000  
③ 最大非规范化数：* 0000000 11111111  
④ 最小非规范化数：* 0000000 00000001  
⑤ 最小规范化浮点数：* 0000001 00000000  
⑥ 最大规范化浮点数：* 1111110 11111111  
⑦ +∞：0 1111111 00000000； -∞：1 1111111 00000000  
⑧NaN:* 11111111 
